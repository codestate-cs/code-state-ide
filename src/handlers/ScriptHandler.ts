import * as vscode from 'vscode';
import { CodeStateService } from '../services/CodeStateService';
import { BaseHandler } from './BaseHandler';
import { 
  VSCODE_TYPES, 
  RESPONSE_STATUS, 
  MessageRequest, 
  MessageResponse
} from '../types';
import { randomUUID } from 'crypto';

export class ScriptHandler implements BaseHandler {
  private codeStateService: CodeStateService;

  constructor() {
    this.codeStateService = CodeStateService.getInstance();
  }

  canHandle(messageType: string): boolean {
    return messageType.startsWith('codestate.script') || 
           messageType === VSCODE_TYPES.SCRIPTS_INIT;
  }

  async handleMessage(message: MessageRequest, webview: vscode.Webview): Promise<void> {
    let response: MessageResponse;

    switch (message.type) {
      case VSCODE_TYPES.SCRIPTS_INIT:
        response = await this.handleScriptsInit(message);
        break;
      
      case VSCODE_TYPES.SCRIPT.CREATE:
        response = await this.handleScriptCreate(message);
        break;
      
      case VSCODE_TYPES.SCRIPT.UPDATE:
        response = await this.handleScriptUpdate(message);
        break;
      
      case VSCODE_TYPES.SCRIPT.DELETE:
        response = await this.handleScriptDelete(message);
        break;
      
      case VSCODE_TYPES.SCRIPT.RESUME:
        response = await this.handleScriptResume(message);
        break;
      
      default:
        return; // Don't handle unknown message types
    }

    // Send response back to webview
    webview.postMessage(response);
  }

  /**
   * Handle scripts init - fetch scripts data
   */
  private async handleScriptsInit(message: MessageRequest): Promise<MessageResponse> {
    const result = await this.codeStateService.getScriptService().getScripts();
    
    if (result.ok) {
      return {
        type: VSCODE_TYPES.SCRIPTS_INIT_RESPONSE,
        status: RESPONSE_STATUS.SUCCESS,
        payload: { scripts: result.value },
        id: message.id
      };
    } else {
      return {
        type: VSCODE_TYPES.SCRIPTS_INIT_RESPONSE,
        status: RESPONSE_STATUS.ERROR,
        payload: { error: result.error.message },
        id: message.id
      };
    }
  }

  /**
   * Handle script create
   */
  private async handleScriptCreate(message: MessageRequest): Promise<MessageResponse> {
    console.log('handleScriptCreate', message);
    try {
      const scriptData = message.payload?.scriptData;
      if (!scriptData) {
        vscode.window.showErrorMessage('No script data provided');
        return {
          type: VSCODE_TYPES.SCRIPT.CREATE_RESPONSE,
          status: RESPONSE_STATUS.ERROR,
          payload: { success: false, error: 'No script data provided' },
          id: message.id
        };
      }
      const id = randomUUID();
      // Use CodeStateService to create the script
      const result = await this.codeStateService.getScriptService().createScript({
        id, // Will be generated by the service
        name: scriptData.name,
        rootPath: scriptData.rootPath,
        commands: scriptData.commands || [],
        lifecycle: scriptData.lifecycle || ['open'],
        executionMode: scriptData.executionMode || 'same-terminal',
        closeTerminalAfterExecution: scriptData.closeTerminalAfterExecution || false
      });

      if (result.ok) {
        vscode.window.showInformationMessage(`Script "${scriptData.name}" created successfully!`);
        return {
          type: VSCODE_TYPES.SCRIPT.CREATE_RESPONSE,
          status: RESPONSE_STATUS.SUCCESS,
          payload: { success: true, id },
          id: message.id
        };
      } else {
        vscode.window.showErrorMessage(`Failed to create script: ${result.error.message}`);
        return {
          type: VSCODE_TYPES.SCRIPT.CREATE_RESPONSE,
          status: RESPONSE_STATUS.ERROR,
          payload: { success: false, error: result.error.message },
          id: message.id
        };
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
      console.error('Script creation error:', error);
      vscode.window.showErrorMessage(`Script creation failed: ${errorMessage}`);
      return {
        type: VSCODE_TYPES.SCRIPT.CREATE_RESPONSE,
        status: RESPONSE_STATUS.ERROR,
        payload: { success: false, error: errorMessage },
        id: message.id
      };
    }
  }

  /**
   * Handle script update
   */
  private async handleScriptUpdate(message: MessageRequest): Promise<MessageResponse> {
    console.log('handleScriptUpdate', message);
    try {
      const scriptId = message.payload?.id;
      const scriptData = message.payload?.scriptData;
      
      if (!scriptId) {
        vscode.window.showErrorMessage('No script ID provided');
        return {
          type: VSCODE_TYPES.SCRIPT.UPDATE_RESPONSE,
          status: RESPONSE_STATUS.ERROR,
          payload: { success: false, error: 'No script ID provided' },
          id: message.id
        };
      }

      if (!scriptData) {
        vscode.window.showErrorMessage('No script data provided');
        return {
          type: VSCODE_TYPES.SCRIPT.UPDATE_RESPONSE,
          status: RESPONSE_STATUS.ERROR,
          payload: { success: false, error: 'No script data provided' },
          id: message.id
        };
      }

      // Use CodeStateService to update the script
      const result = await this.codeStateService.getScriptService().updateScript(scriptId, {
        name: scriptData.name,
        rootPath: scriptData.rootPath,
        commands: scriptData.commands || [],
        lifecycle: scriptData.lifecycle || ['open'],
        executionMode: scriptData.executionMode || 'same-terminal',
        closeTerminalAfterExecution: scriptData.closeTerminalAfterExecution || false
      });

      if (result.ok) {
        vscode.window.showInformationMessage(`Script "${scriptData.name}" updated successfully!`);
        return {
          type: VSCODE_TYPES.SCRIPT.UPDATE_RESPONSE,
          status: RESPONSE_STATUS.SUCCESS,
          payload: { success: true, id: scriptId },
          id: message.id
        };
      } else {
        vscode.window.showErrorMessage(`Failed to update script: ${result.error.message}`);
        return {
          type: VSCODE_TYPES.SCRIPT.UPDATE_RESPONSE,
          status: RESPONSE_STATUS.ERROR,
          payload: { success: false, error: result.error.message },
          id: message.id
        };
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
      console.error('Script update error:', error);
      vscode.window.showErrorMessage(`Script update failed: ${errorMessage}`);
      return {
        type: VSCODE_TYPES.SCRIPT.UPDATE_RESPONSE,
        status: RESPONSE_STATUS.ERROR,
        payload: { success: false, error: errorMessage },
        id: message.id
      };
    }
  }

  /**
   * Handle script delete
   */
  private async handleScriptDelete(message: MessageRequest): Promise<MessageResponse> {
    console.log('handleScriptDelete', message);
    try {
      const scriptId = message.payload?.id;
      if (!scriptId) {
        vscode.window.showErrorMessage('No script ID provided');
        return {
          type: VSCODE_TYPES.SCRIPT.DELETE_RESPONSE,
          status: RESPONSE_STATUS.ERROR,
          payload: { success: false, error: 'No script ID provided' },
          id: message.id
        };
      }

      // Use CodeStateService to delete the script
      const result = await this.codeStateService.getScriptService().deleteScripts([scriptId]);

      if (result.ok) {
        vscode.window.showInformationMessage(`Script deleted successfully!`);
        return {
          type: VSCODE_TYPES.SCRIPT.DELETE_RESPONSE,
          status: RESPONSE_STATUS.SUCCESS,
          payload: { success: true, id: scriptId },
          id: message.id
        };
      } else {
        vscode.window.showErrorMessage(`Failed to delete script: ${result.error.message}`);
        return {
          type: VSCODE_TYPES.SCRIPT.DELETE_RESPONSE,
          status: RESPONSE_STATUS.ERROR,
          payload: { success: false, error: result.error.message },
          id: message.id
        };
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
      console.error('Script deletion error:', error);
      vscode.window.showErrorMessage(`Script deletion failed: ${errorMessage}`);
      return {
        type: VSCODE_TYPES.SCRIPT.DELETE_RESPONSE,
        status: RESPONSE_STATUS.ERROR,
        payload: { success: false, error: errorMessage },
        id: message.id
      };
    }
  }

  /**
   * Handle script resume
   */
  private async handleScriptResume(message: MessageRequest): Promise<MessageResponse> {
    console.log('handleScriptResume', message);
    try {
      const scriptId = message.payload?.id;
      if (!scriptId) {
        vscode.window.showErrorMessage('No script ID provided');
        return {
          type: VSCODE_TYPES.SCRIPT.RESUME_RESPONSE,
          status: RESPONSE_STATUS.ERROR,
          payload: { success: false, error: 'No script ID provided' },
          id: message.id
        };
      }

      // Use CodeStateService to resume the script
      const result = await this.codeStateService.getScriptService().resumeScript(scriptId);

      if (result.ok) {
        vscode.window.showInformationMessage(`Script resumed successfully!`);
        return {
          type: VSCODE_TYPES.SCRIPT.RESUME_RESPONSE,
          status: RESPONSE_STATUS.SUCCESS,
          payload: { success: true, id: scriptId },
          id: message.id
        };
      } else {
        vscode.window.showErrorMessage(`Failed to resume script: ${result.error.message}`);
        return {
          type: VSCODE_TYPES.SCRIPT.RESUME_RESPONSE,
          status: RESPONSE_STATUS.ERROR,
          payload: { success: false, error: result.error.message },
          id: message.id
        };
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
      console.error('Script resume error:', error);
      vscode.window.showErrorMessage(`Script resume failed: ${errorMessage}`);
      return {
        type: VSCODE_TYPES.SCRIPT.RESUME_RESPONSE,
        status: RESPONSE_STATUS.ERROR,
        payload: { success: false, error: errorMessage },
        id: message.id
      };
    }
  }
}