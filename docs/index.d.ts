// Generated by dts-bundle-generator v9.5.1

import { z } from 'zod';

export interface Script {
	id: string;
	name: string;
	rootPath: string;
	script?: string;
	commands?: ScriptCommand[];
	lifecycle?: LifecycleEvent[];
	executionMode?: "same-terminal" | "new-terminals";
	closeTerminalAfterExecution?: boolean;
}
export interface ScriptCommand {
	command: string;
	name: string;
	priority: number;
}
export interface ScriptIndexEntry {
	id: string;
	rootPath: string;
	referenceFile: string;
}
export interface ScriptIndex {
	entries: ScriptIndexEntry[];
}
export interface ScriptCollection {
	scripts: Script[];
}
export type LifecycleEvent = "open" | "resume" | "none";
export interface ScriptReference {
	id: string;
	rootPath: string;
}
export interface TerminalCollection {
	id: string;
	name: string;
	rootPath: string;
	lifecycle: LifecycleEvent[];
	scriptReferences: ScriptReference[];
	closeTerminalAfterExecution?: boolean;
}
export interface TerminalCollectionWithScripts {
	id: string;
	name: string;
	rootPath: string;
	lifecycle: LifecycleEvent[];
	scripts: Script[];
	closeTerminalAfterExecution?: boolean;
}
export interface TerminalCollectionIndexEntry {
	id: string;
	name: string;
	rootPath: string;
	referenceFile: string;
}
export interface TerminalCollectionIndex {
	entries: TerminalCollectionIndexEntry[];
}
export interface Session {
	id: string;
	name: string;
	projectRoot: string;
	createdAt: Date;
	updatedAt: Date;
	tags: string[];
	notes?: string;
	files: FileState[];
	git: GitState;
	extensions?: Record<string, unknown>;
	terminalCommands?: TerminalCommandState[];
	terminalCollections?: string[];
	scripts?: string[];
}
export interface SessionWithFullData extends Session {
	terminalCollectionsData?: TerminalCollectionWithScripts[];
	scriptsData?: Script[];
}
export interface FileState {
	path: string;
	cursor?: {
		line: number;
		column: number;
	};
	scroll?: {
		top: number;
		left: number;
	};
	isActive: boolean;
	position?: number;
}
export interface GitState {
	branch: string;
	commit: string;
	isDirty: boolean;
	stashId?: string | null;
}
export interface TerminalCommandState {
	terminalId: number;
	terminalName?: string;
	commands: SessionTerminalCommand[];
}
export interface SessionTerminalCommand {
	command: string;
	name: string;
	priority: number;
}
declare const LoggerConfigSchema: z.ZodObject<{
	level: z.ZodEnum<{
		ERROR: "ERROR";
		WARN: "WARN";
		LOG: "LOG";
		DEBUG: "DEBUG";
	}>;
	sinks: z.ZodArray<z.ZodEnum<{
		file: "file";
		console: "console";
	}>>;
	filePath: z.ZodOptional<z.ZodString>;
}, z.core.$strip>;
export type LoggerConfig = z.infer<typeof LoggerConfigSchema>;
export interface EncryptionConfig {
	enabled: boolean;
	encryptionKey?: string;
}
export interface Config {
	version: string;
	ide: string;
	encryption: EncryptionConfig;
	storagePath: string;
	logger: LoggerConfig;
	experimental?: Record<string, boolean>;
	extensions?: Record<string, unknown>;
}
export type Result<T, E = Error> = Success<T> | Failure<E>;
export interface Success<T> {
	ok: true;
	value: T;
}
export interface Failure<E> {
	ok: false;
	error: E;
}
export declare function isSuccess<T, E = Error>(result: Result<T, E>): result is Success<T>;
export declare function isFailure<T, E = Error>(result: Result<T, E>): result is Failure<E>;
export interface IConfigService {
	getConfig(): Promise<Result<Config>>;
	setConfig(config: Config): Promise<Result<void>>;
	updateConfig(partial: Partial<Config>): Promise<Result<Config>>;
}
export declare class GetConfig {
	private configService;
	constructor(configService?: IConfigService);
	execute(): Promise<Result<Config>>;
}
export declare class UpdateConfig {
	private configService;
	constructor(configService?: IConfigService);
	execute(partial: Partial<Config>): Promise<Result<Config>>;
}
export declare class ResetConfig {
	private configService;
	constructor(configService?: IConfigService);
	execute(): Promise<Result<Config>>;
}
export type ResetOptions = {
	sessions?: boolean;
	scripts?: boolean;
	terminals?: boolean;
	config?: boolean;
	all?: boolean;
};
export declare class ResetAll {
	private fileStorage;
	private dataDir;
	private configService;
	constructor(dataDir?: string);
	private initializeServices;
	private ensureDataDir;
	private getDefaultDataDir;
	execute(options: ResetOptions): Promise<Result<{
		resetItems: string[];
	}>>;
	private resetSessions;
	private resetScripts;
	private resetTerminals;
	private resetConfig;
	private cleanupDataDirectory;
}
export interface VersionInfo {
	currentVersion: string;
	storedVersion: string;
	requiresReset: boolean;
	isUpgrade: boolean;
}
export declare class CheckVersionUpgrade {
	private configService;
	private logger;
	private readonly MINIMUM_RESET_VERSION;
	private readonly CURRENT_VERSION;
	constructor(configService?: IConfigService);
	execute(): Promise<Result<VersionInfo>>;
	private shouldRequireReset;
	private isVersionUpgrade;
	private parseVersion;
	private compareVersions;
}
export declare class ExportConfig {
	private configService;
	constructor(configService?: IConfigService);
	execute(): Promise<Result<string>>;
}
export declare class ImportConfig {
	private configService;
	constructor(configService?: IConfigService);
	execute(json: string): Promise<Result<Config>>;
}
export declare function getDefaultConfig(dataDir?: string): Config;
export interface ExportOptions {
	rootPath?: string;
	lifecycle?: LifecycleEvent;
	scriptIds?: string[];
	filename?: string;
	includeMetadata?: boolean;
	selectionMode?: "filter" | "ids" | "interactive";
}
export interface ExportResult {
	filePath: string;
	scriptCount: number;
	exportedAt: string;
	selectedScripts: Script[];
	filters: {
		rootPath?: string;
		lifecycle?: LifecycleEvent;
		scriptIds?: string[];
	};
}
export declare class ExportScripts {
	private scriptService;
	constructor();
	execute(options?: ExportOptions): Promise<Result<ExportResult>>;
	private getScriptsByIds;
	private getScriptsByFilters;
	private ensureExportDirectory;
	private getDownloadsPath;
	private generateFilename;
}
export interface ImportOptions {
	conflictResolution?: "skip" | "overwrite" | "rename";
	dryRun?: boolean;
}
export interface ImportResult {
	created: number;
	skipped: number;
	errors: string[];
	totalProcessed: number;
}
export declare class ImportScripts {
	private scriptService;
	constructor();
	execute(filePath: string, options?: ImportOptions): Promise<Result<ImportResult>>;
	private extractScripts;
	private validateScripts;
	private processScript;
	private generateUniqueName;
}
export interface IScriptService {
	createScript(script: Script): Promise<Result<void>>;
	getScriptById(id: string): Promise<Result<Script>>;
	getScripts(options?: {
		rootPath?: string;
		lifecycle?: LifecycleEvent;
	}): Promise<Result<Script[]>>;
	updateScript(id: string, script: Partial<Script>): Promise<Result<void>>;
	deleteScripts(ids: string[]): Promise<Result<void>>;
	exportScripts(options?: ExportOptions): Promise<Result<ExportResult>>;
	importScripts(filePath: string, options?: ImportOptions): Promise<Result<ImportResult>>;
}
export declare class CreateScript {
	private scriptService;
	constructor(scriptService?: IScriptService);
	execute(script: Script): Promise<Result<void>>;
}
export declare class GetScripts {
	private scriptService;
	constructor(scriptService?: IScriptService);
	execute(options?: {
		rootPath?: string;
		lifecycle?: LifecycleEvent;
	}): Promise<Result<Script[]>>;
}
export interface TerminalCommand {
	command: string;
	args?: string[];
	cwd?: string;
	env?: Record<string, string>;
	timeout?: number;
}
export interface TerminalResult {
	success: boolean;
	exitCode: number;
	stdout: string;
	stderr: string;
	duration: number;
	error?: string;
}
export interface TerminalOptions {
	cwd?: string;
	env?: Record<string, string>;
	timeout?: number;
	shell?: string;
}
export interface ITerminalService {
	execute(command: string, options?: TerminalOptions): Promise<Result<TerminalResult>>;
	executeCommand(command: TerminalCommand): Promise<Result<TerminalResult>>;
	executeBatch(commands: TerminalCommand[]): Promise<Result<TerminalResult[]>>;
	spawnTerminal(command: string, options?: TerminalOptions): Promise<Result<boolean>>;
	spawnTerminalCommand(command: TerminalCommand): Promise<Result<boolean>>;
	spawnApplication(command: string, options?: TerminalOptions): Promise<Result<boolean>>;
	getLastCommandsFromTerminals(): Promise<Result<TerminalCommandState[]>>;
	isCommandAvailable(command: string): Promise<Result<boolean>>;
	getShell(): Promise<Result<string>>;
}
export declare class ResumeScript {
	private terminalService;
	private scriptService;
	constructor(terminalService?: ITerminalService);
	execute(scriptId: string): Promise<Result<void>>;
}
export declare class UpdateScript {
	private scriptService;
	constructor(scriptService?: IScriptService);
	execute(id: string, scriptUpdate: Partial<Script>): Promise<Result<void>>;
}
export declare class DeleteScript {
	private scriptService;
	constructor(scriptService?: IScriptService);
	execute(ids: string[]): Promise<Result<void>>;
}
export interface ISessionService {
	saveSession(input: Partial<Session> & {
		name: string;
		projectRoot: string;
		notes?: string;
		tags?: string[];
	}): Promise<Result<Session>>;
	updateSession(idOrName: string, input: Partial<Session> & {
		notes?: string;
		tags?: string[];
		terminalCollections?: string[];
		scripts?: string[];
	}): Promise<Result<Session>>;
	getSessionById(idOrName: string): Promise<Result<Session>>;
	resumeSession(idOrName: string): Promise<Result<Session>>;
	listSessions(filter?: {
		tags?: string[];
		search?: string;
		loadAll?: boolean;
	}): Promise<Result<Session[] | SessionWithFullData[]>>;
	deleteSession(idOrName: string): Promise<Result<void>>;
	exportSession(idOrName: string, outputPath: string): Promise<Result<void>>;
	importSession(filePath: string): Promise<Result<Session>>;
}
export declare class SaveSession {
	private sessionService;
	constructor(sessionService?: ISessionService);
	execute(input: {
		name: string;
		projectRoot: string;
		notes?: string;
		tags?: string[];
		files?: Session["files"];
		git: Session["git"];
		extensions?: Session["extensions"];
		terminalCommands?: Session["terminalCommands"];
		terminalCollections?: Session["terminalCollections"];
		scripts?: Session["scripts"];
	}): Promise<Result<Session>>;
}
export declare class UpdateSession {
	private sessionService;
	constructor(sessionService?: ISessionService);
	execute(idOrName: string, input: {
		notes?: string;
		tags?: string[];
		files?: Session["files"];
		git?: Session["git"];
		extensions?: Session["extensions"];
		terminalCommands?: Session["terminalCommands"];
		terminalCollections?: Session["terminalCollections"];
		scripts?: Session["scripts"];
	}): Promise<Result<Session>>;
}
export declare class DeleteSession {
	private sessionService;
	constructor(sessionService?: ISessionService);
	execute(idOrName: string): Promise<Result<void>>;
}
export declare class ListSessions {
	private sessionService;
	constructor(sessionService?: ISessionService);
	execute(filter?: {
		tags?: string[];
		search?: string;
		loadAll?: boolean;
	}): Promise<Result<Session[] | SessionWithFullData[]>>;
}
export declare class GetSession {
	private sessionService;
	constructor(sessionService?: ISessionService);
	execute(idOrName: string): Promise<Result<Session>>;
}
export interface ILoggerService {
	log(message: string, meta?: Record<string, unknown>): void;
	error(message: string, meta?: Record<string, unknown>): void;
	warn(message: string, meta?: Record<string, unknown>): void;
	debug(message: string, meta?: Record<string, unknown>): void;
	plainLog(message: string, meta?: Record<string, unknown>): void;
}
export declare class ResumeSession {
	private sessionService;
	private logger;
	constructor(sessionService?: ISessionService, logger?: ILoggerService);
	execute(idOrName: string): Promise<Result<Session>>;
}
export interface ExportSessionOptions {
	tags?: string[];
	search?: string;
	sessionIds?: string[];
	filename?: string;
	includeMetadata?: boolean;
	selectionMode?: "filter" | "ids" | "interactive";
}
export interface ExportSessionResult {
	filePath: string;
	sessionCount: number;
	scriptCount: number;
	terminalCollectionCount: number;
	exportedAt: string;
	selectedSessions: SessionWithDependencies[];
	filters: {
		tags?: string[];
		search?: string;
		sessionIds?: string[];
	};
}
export interface SessionWithDependencies extends Session {
	bundledScripts?: any[];
	bundledTerminalCollections?: any[];
}
export declare class ExportSessions {
	private sessionService;
	private scriptService;
	private terminalCollectionService;
	constructor();
	execute(options?: ExportSessionOptions): Promise<Result<ExportSessionResult>>;
	private getSessionsByIds;
	private getSessionsByFilters;
	private bundleSessionDependencies;
	private ensureExportDirectory;
	private getDownloadsPath;
	private generateFilename;
}
export interface ImportSessionOptions {
	conflictResolution?: "skip" | "overwrite" | "rename";
	dryRun?: boolean;
	updatePaths?: boolean;
}
export interface ImportSessionResult {
	created: number;
	skipped: number;
	errors: string[];
	totalProcessed: number;
	scriptsCreated: number;
	scriptsSkipped: number;
	terminalCollectionsCreated: number;
	terminalCollectionsSkipped: number;
}
export declare class ImportSessions {
	private sessionService;
	private scriptService;
	private terminalCollectionService;
	constructor();
	execute(filePath: string, options?: ImportSessionOptions): Promise<Result<ImportSessionResult>>;
	private extractSessions;
	private validateSessions;
	private processSession;
	private generateUniqueSessionName;
	private importDependencies;
}
export interface GitStatus {
	isDirty: boolean;
	dirtyFiles: GitFile[];
	newFiles: GitFile[];
	modifiedFiles: GitFile[];
	deletedFiles: GitFile[];
	untrackedFiles: GitFile[];
}
export interface GitFile {
	path: string;
	status: GitFileStatus;
	staged: boolean;
}
declare enum GitFileStatus {
	MODIFIED = "modified",
	ADDED = "added",
	DELETED = "deleted",
	UNTRACKED = "untracked",
	RENAMED = "renamed",
	COPIED = "copied",
	UPDATED = "updated"
}
export interface GitStash {
	id: string;
	name: string;
	message: string;
	timestamp: number;
	branch: string;
}
export interface GitStashResult {
	success: boolean;
	stashId?: string;
	error?: string;
}
export interface GitStashApplyResult {
	success: boolean;
	conflicts?: string[];
	error?: string;
}
export interface IGitService {
	getIsDirty(): Promise<Result<boolean>>;
	getDirtyData(): Promise<Result<GitStatus>>;
	getStatus(): Promise<Result<GitStatus>>;
	createStash(message?: string): Promise<Result<GitStashResult>>;
	applyStash(stashName: string): Promise<Result<GitStashApplyResult>>;
	listStashes(): Promise<Result<GitStash[]>>;
	deleteStash(stashName: string): Promise<Result<boolean>>;
	isGitRepository(): Promise<Result<boolean>>;
	getCurrentBranch(): Promise<Result<string>>;
	getCurrentCommit(): Promise<Result<string>>;
	commitChanges(message: string): Promise<Result<boolean>>;
	isGitConfigured(): Promise<Result<boolean>>;
	getRepositoryRoot(): Promise<Result<string>>;
}
export declare class GetGitStatus {
	private gitService;
	constructor(gitService?: IGitService, repositoryPath?: string);
	execute(): Promise<Result<GitStatus>>;
}
export declare class GetIsDirty {
	private gitService;
	constructor(gitService?: IGitService, repositoryPath?: string);
	execute(): Promise<Result<boolean>>;
}
export declare class GetDirtyData {
	private gitService;
	constructor(gitService?: IGitService, repositoryPath?: string);
	execute(): Promise<Result<GitStatus>>;
}
export declare class CreateStash {
	private gitService;
	constructor(gitService?: IGitService, repositoryPath?: string);
	execute(message?: string): Promise<Result<GitStashResult>>;
}
export declare class ApplyStash {
	private gitService;
	constructor(gitService?: IGitService, repositoryPath?: string);
	execute(stashName: string): Promise<Result<GitStashApplyResult>>;
}
export declare class ListStashes {
	private gitService;
	constructor(gitService?: IGitService, repositoryPath?: string);
	execute(): Promise<Result<GitStash[]>>;
}
export declare class DeleteStash {
	private gitService;
	constructor(gitService?: IGitService, repositoryPath?: string);
	execute(stashName: string): Promise<Result<boolean>>;
}
export declare class GetCurrentCommit {
	private gitService;
	constructor(gitService?: IGitService);
	execute(): Promise<Result<string>>;
}
export declare class CommitChanges {
	private gitService;
	constructor(gitService?: IGitService);
	execute(message: string): Promise<Result<boolean>>;
}
export interface IDE {
	name: string;
	command: string;
	args: string[];
	supportedPlatforms: string[];
}
export interface FileOpenRequest {
	ide: string;
	projectRoot: string;
	files: FileToOpen[];
}
export interface FileToOpen {
	path: string;
	line?: number;
	column?: number;
	isActive?: boolean;
}
export interface IIDEService {
	openIDE(ideName: string, projectRoot: string): Promise<Result<boolean>>;
	openFiles(request: FileOpenRequest): Promise<Result<boolean>>;
	getAvailableIDEs(): Promise<Result<IDE[]>>;
	isIDEInstalled(ideName: string): Promise<Result<boolean>>;
}
export declare class OpenIDE {
	private ideService;
	constructor(ideService?: IIDEService);
	execute(ideName: string, projectRoot: string): Promise<Result<boolean>>;
}
export declare class OpenFiles {
	private ideService;
	constructor(ideService?: IIDEService);
	execute(request: FileOpenRequest): Promise<Result<boolean>>;
}
export declare class GetAvailableIDEs {
	private ideService;
	constructor(ideService?: IIDEService);
	execute(): Promise<Result<IDE[]>>;
}
export interface ITerminalCollectionService {
	createTerminalCollection(terminalCollection: TerminalCollection): Promise<Result<void>>;
	getTerminalCollectionById(id: string): Promise<Result<TerminalCollection>>;
	getTerminalCollections(options?: {
		rootPath?: string;
		lifecycle?: LifecycleEvent;
		loadScripts?: boolean;
	}): Promise<Result<TerminalCollection[] | TerminalCollectionWithScripts[]>>;
	updateTerminalCollection(id: string, terminalCollectionUpdate: Partial<TerminalCollection>): Promise<Result<void>>;
	deleteTerminalCollections(ids: string[]): Promise<Result<void>>;
	executeTerminalCollectionById(id: string): Promise<Result<void>>;
}
export declare class ListTerminalCollections {
	private terminalCollectionService;
	constructor(terminalCollectionService?: ITerminalCollectionService);
	execute(): Promise<Result<TerminalCollectionWithScripts[]>>;
}
export interface GetTerminalCollectionsOptions {
	rootPath?: string;
	lifecycle?: LifecycleEvent;
	loadScripts?: boolean;
}
export declare class GetTerminalCollections {
	private terminalCollectionService;
	constructor(terminalCollectionService?: ITerminalCollectionService);
	execute(options?: GetTerminalCollectionsOptions): Promise<Result<TerminalCollectionWithScripts[]>>;
}
export declare class GetTerminalCollectionById {
	private terminalCollectionService;
	constructor(terminalCollectionService?: ITerminalCollectionService);
	execute(id: string): Promise<Result<TerminalCollection>>;
}
export declare class CreateTerminalCollection {
	private terminalCollectionService;
	constructor(terminalCollectionService?: ITerminalCollectionService);
	execute(terminalCollection: TerminalCollection): Promise<Result<void>>;
}
export declare class UpdateTerminalCollection {
	private terminalCollectionService;
	constructor(terminalCollectionService?: ITerminalCollectionService);
	execute(id: string, terminalCollectionUpdate: Partial<TerminalCollection>): Promise<Result<void>>;
}
export declare class DeleteTerminalCollections {
	private terminalCollectionService;
	constructor(terminalCollectionService?: ITerminalCollectionService);
	execute(ids: string[]): Promise<Result<void>>;
}
export declare class ExecuteTerminalCollection {
	private terminalCollectionService;
	constructor(terminalCollectionService?: ITerminalCollectionService);
	execute(id: string): Promise<Result<void>>;
}
export interface ExportTerminalCollectionOptions {
	rootPath?: string;
	lifecycle?: LifecycleEvent;
	terminalCollectionIds?: string[];
	filename?: string;
	includeMetadata?: boolean;
	selectionMode?: "filter" | "ids" | "interactive";
}
export interface ExportTerminalCollectionResult {
	filePath: string;
	terminalCollectionCount: number;
	scriptCount: number;
	exportedAt: string;
	selectedTerminalCollections: TerminalCollectionWithScripts[];
	filters: {
		rootPath?: string;
		lifecycle?: LifecycleEvent;
		terminalCollectionIds?: string[];
	};
}
export declare class ExportTerminalCollections {
	private terminalCollectionService;
	constructor();
	execute(options?: ExportTerminalCollectionOptions): Promise<Result<ExportTerminalCollectionResult>>;
	private getTerminalCollectionsByIds;
	private getTerminalCollectionsByFilters;
	private ensureExportDirectory;
	private getDownloadsPath;
	private generateFilename;
}
export interface ImportTerminalCollectionOptions {
	conflictResolution?: "skip" | "overwrite" | "rename";
	dryRun?: boolean;
	updatePaths?: boolean;
}
export interface ImportTerminalCollectionResult {
	created: number;
	skipped: number;
	errors: string[];
	totalProcessed: number;
	scriptsCreated: number;
	scriptsSkipped: number;
}
export declare class ImportTerminalCollections {
	private terminalCollectionService;
	private scriptService;
	constructor();
	execute(filePath: string, options?: ImportTerminalCollectionOptions): Promise<Result<ImportTerminalCollectionResult>>;
	private extractTerminalCollections;
	private validateTerminalCollections;
	private processTerminalCollection;
	private generateUniqueTerminalCollectionName;
	private importScripts;
}
export declare enum ErrorCode {
	UNKNOWN = "UNKNOWN",
	CONFIG_INVALID = "CONFIG_INVALID",
	STORAGE_INVALID_PATH = "STORAGE_INVALID_PATH",
	STORAGE_DECRYPTION_FAILED = "STORAGE_DECRYPTION_FAILED",
	STORAGE_READ_FAILED = "STORAGE_READ_FAILED",
	STORAGE_WRITE_FAILED = "STORAGE_WRITE_FAILED",
	STORAGE_DELETE_FAILED = "STORAGE_DELETE_FAILED",
	ENCRYPTION_FAILED = "ENCRYPTION_FAILED",
	ENCRYPTION_INVALID_FORMAT = "ENCRYPTION_INVALID_FORMAT",
	SCRIPT_INVALID = "SCRIPT_INVALID",
	SCRIPT_DUPLICATE = "SCRIPT_DUPLICATE",
	SCRIPT_NOT_FOUND = "SCRIPT_NOT_FOUND",
	SCRIPT_PATH_INVALID = "SCRIPT_PATH_INVALID",
	SCRIPT_MALICIOUS = "SCRIPT_MALICIOUS",
	GIT_NOT_REPOSITORY = "GIT_NOT_REPOSITORY",
	GIT_COMMAND_FAILED = "GIT_COMMAND_FAILED",
	GIT_STASH_NOT_FOUND = "GIT_STASH_NOT_FOUND",
	GIT_STASH_CONFLICT = "GIT_STASH_CONFLICT",
	TERMINAL_COMMAND_FAILED = "TERMINAL_COMMAND_FAILED",
	TERMINAL_TIMEOUT = "TERMINAL_TIMEOUT",
	TERMINAL_COMMAND_NOT_FOUND = "TERMINAL_COMMAND_NOT_FOUND"
}
export interface StandardizedErrorShape {
	code: ErrorCode;
	name: string;
	message: string;
	meta?: Record<string, unknown>;
}
export declare class AppError extends Error implements StandardizedErrorShape {
	code: ErrorCode;
	meta?: Record<string, unknown>;
	constructor(message: string, code?: ErrorCode, meta?: Record<string, unknown>);
}
export declare class ConfigError extends AppError {
	constructor(message: string, meta?: Record<string, unknown>);
}
export declare class StorageError extends AppError {
	constructor(message: string, code?: ErrorCode, meta?: Record<string, unknown>);
}
export declare class EncryptionError extends AppError {
	constructor(message: string, code?: ErrorCode, meta?: Record<string, unknown>);
}
export declare class ScriptError extends AppError {
	constructor(message: string, code?: ErrorCode, meta?: Record<string, unknown>);
}
export declare class GitError extends AppError {
	constructor(message: string, code?: ErrorCode, meta?: Record<string, unknown>);
}
export declare class TerminalError extends AppError {
	constructor(message: string, code?: ErrorCode, meta?: Record<string, unknown>);
}
export interface ErrorRegistryEntry {
	code: ErrorCode;
	userMessage: string;
	exitCode: number;
}
export declare const ErrorRegistry: Record<ErrorCode, ErrorRegistryEntry>;
export declare function getUserMessageForErrorCode(code: ErrorCode): string;
export declare function getExitCodeForErrorCode(code: ErrorCode): number;
declare class CLILoggerFacade {
	private logger;
	constructor();
	log(message: string, meta?: Record<string, unknown>): void;
	error(message: string, meta?: Record<string, unknown>): void;
	warn(message: string, meta?: Record<string, unknown>): void;
	plainLog(message: string, meta?: Record<string, unknown>): void;
}
declare class TerminalFacade implements ITerminalService {
	private service;
	constructor(logger?: ILoggerService);
	execute(command: string, options?: TerminalOptions): Promise<Result<TerminalResult>>;
	executeCommand(command: TerminalCommand): Promise<Result<TerminalResult>>;
	executeBatch(commands: TerminalCommand[]): Promise<Result<TerminalResult[]>>;
	spawnTerminal(command: string, options?: TerminalOptions): Promise<Result<boolean>>;
	spawnTerminalCommand(command: TerminalCommand): Promise<Result<boolean>>;
	spawnApplication(command: string, options?: TerminalOptions): Promise<Result<boolean>>;
	isCommandAvailable(command: string): Promise<Result<boolean>>;
	getShell(): Promise<Result<string>>;
	getLastCommandsFromTerminals(): Promise<Result<TerminalCommandState[]>>;
}
declare class IDEFacade implements IIDEService {
	private service;
	constructor();
	openIDE(ideName: string, projectRoot: string): Promise<Result<boolean>>;
	openFiles(request: any): Promise<Result<boolean>>;
	getAvailableIDEs(): Promise<Result<IDE[]>>;
	isIDEInstalled(ideName: string): Promise<Result<boolean>>;
}
export interface IStorageService {
	read(path: string): Promise<Result<string, StorageError>>;
	write(path: string, data: string): Promise<Result<void, StorageError>>;
	exists(path: string): Promise<Result<boolean, StorageError>>;
	delete(path: string): Promise<Result<void, StorageError>>;
}
export interface IEncryptionService {
	encrypt(data: string, key: string): Promise<Result<string, EncryptionError>>;
	decrypt(data: string, key: string): Promise<Result<string, EncryptionError>>;
}
export interface FileStorageConfig {
	encryptionEnabled?: boolean;
	encryptionKey?: string;
	dataDir?: string;
}
declare class FileStorageFacade implements IStorageService {
	private service;
	constructor(config?: FileStorageConfig, logger?: ILoggerService, encryption?: IEncryptionService);
	read(path: string): Promise<Result<string, StorageError>>;
	write(path: string, data: string): Promise<Result<void, StorageError>>;
	exists(path: string): Promise<Result<boolean, StorageError>>;
	delete(path: string): Promise<Result<void, StorageError>>;
}
export declare class ScriptFacade implements IScriptService {
	private service;
	constructor(scriptsDir?: string, logger?: ILoggerService, encryption?: IEncryptionService, configService?: IConfigService);
	createScript(...args: Parameters<IScriptService["createScript"]>): Promise<Result<void>>;
	getScriptById(...args: Parameters<IScriptService["getScriptById"]>): Promise<Result<Script>>;
	getScripts(...args: Parameters<IScriptService["getScripts"]>): Promise<Result<Script[]>>;
	updateScript(...args: Parameters<IScriptService["updateScript"]>): Promise<Result<void>>;
	deleteScripts(...args: Parameters<IScriptService["deleteScripts"]>): Promise<Result<void>>;
	exportScripts(...args: Parameters<IScriptService["exportScripts"]>): Promise<Result<ExportResult>>;
	importScripts(...args: Parameters<IScriptService["importScripts"]>): Promise<Result<ImportResult>>;
}
export declare class TerminalCollectionFacade implements ITerminalCollectionService {
	private service;
	constructor(terminalsDir?: string, logger?: ILoggerService, encryption?: IEncryptionService);
	createTerminalCollection(terminalCollection: any): Promise<any>;
	getTerminalCollectionById(id: string): Promise<any>;
	getTerminalCollections(options?: {
		rootPath?: string;
		lifecycle?: any;
		loadScripts?: boolean;
	}): Promise<any>;
	updateTerminalCollection(id: string, terminalCollectionUpdate: any): Promise<any>;
	deleteTerminalCollections(ids: string[]): Promise<any>;
	executeTerminalCollectionById(id: string): Promise<any>;
}
declare class GitFacade implements IGitService {
	private service;
	constructor(repositoryPath?: string, logger?: ILoggerService, terminalService?: ITerminalService);
	getCurrentCommit(...args: Parameters<IGitService["getCurrentCommit"]>): Promise<Result<string>>;
	isGitConfigured(...args: Parameters<IGitService["isGitConfigured"]>): Promise<Result<boolean>>;
	commitChanges(...args: Parameters<IGitService["commitChanges"]>): Promise<Result<boolean>>;
	getIsDirty(...args: Parameters<IGitService["getIsDirty"]>): Promise<Result<boolean>>;
	getDirtyData(...args: Parameters<IGitService["getDirtyData"]>): Promise<Result<GitStatus>>;
	getStatus(...args: Parameters<IGitService["getStatus"]>): Promise<Result<GitStatus>>;
	createStash(...args: Parameters<IGitService["createStash"]>): Promise<Result<GitStashResult>>;
	applyStash(...args: Parameters<IGitService["applyStash"]>): Promise<Result<GitStashApplyResult>>;
	listStashes(...args: Parameters<IGitService["listStashes"]>): Promise<Result<GitStash[]>>;
	deleteStash(...args: Parameters<IGitService["deleteStash"]>): Promise<Result<boolean>>;
	isGitRepository(...args: Parameters<IGitService["isGitRepository"]>): Promise<Result<boolean>>;
	getCurrentBranch(...args: Parameters<IGitService["getCurrentBranch"]>): Promise<Result<string>>;
	getRepositoryRoot(...args: Parameters<IGitService["getRepositoryRoot"]>): Promise<Result<string>>;
}

export {
	CLILoggerFacade as ConfigurableLogger,
	FileStorageFacade as FileStorage,
	GitFacade as GitService,
	IDEFacade as IDEService,
	TerminalFacade as Terminal,
};

export {};
